# -*- coding: utf-8 -*-
"""Untitled15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o3M6aeLISw1S1mcoUaVqiW5VvhpYa26o
"""

import numpy as np
import itertools
import pandas as pd

s="ACUGCAACCGUG"
'''
A:0,5,6
U:2,10
C:1,4,7,8
G:3,9,11
'''
n =len(s)
maxP = int(np.floor(n/2))
A = ''
U = ''
C = ''
G = ''
AUCG = {"A":[],"U":[],"C":[],"G":[]}
for i in range(n):
    AUCG[s[i]].append(i)
print(AUCG)
o = len(AUCG)
RNA ={"A":"U","U":"A","C":"G","G":"C"}
maxP

"""##node is one list like [a,b] of length 2

##nodes is the list of all nodes of length maxN

##lastNodes is the list of all nodes that do not have child

##IG is the dictionary with keys of node in tuple format tuple(node), and values of a list of nodes that the key can contain(next level only).
  
##ITG is the dictionary with keys of node in tuple format tuple(node), and values of a list of nodes that the key next to(non-cross).
"""

M = np.zeros((n,n))
nodes = []
for r in range(n):
  for c in range(r,n):
    if RNA[s[r]] == s[c]:
      M[r][c] = 1
      nodes.append([r,c])

print(M)
print(sum(sum(M)))
#print(M>0)
#all nodes
print(nodes)

print(M[1:4,1:4],sum(sum(M[1:4,1:4])))

def PairOnes(matrix, row, column):
  '''
  sum alone rows and columns (both excluded)
  '''
  if column <= row+1:
    return 0
  return sum(sum(matrix[row+1:column,row+1:column]))

print(PairOnes(M, 0, 2))
print(PairOnes(M, 2, 12))

#inside [1,9]?
[[ir,ic] for ir in range(2,9) for ic in range(2,9) if [ir,ic] in nodes]

#intra-grow
IG = {}
Leaves = []
maxN = len(nodes)
for ni in range(maxN):
  lr = nodes[ni][0]
  lc = nodes[ni][1]
  print(lr,lc,PairOnes(M, lr, lc))
  if PairOnes(M, lr, lc) >0:
    print([[ir,ic] for ir in range(lr+1,lc) for ic in range(lr+1,lc) if [ir,ic] in nodes])
    IG[(lr,lc)]=[[ir,ic] for ir in range(lr+1,lc) for ic in range(lr+1,lc) if [ir,ic] in nodes]
  else:
    Leaves.append([lr,lc])
print(IG)
print(Leaves)
print(nodes[0] in Leaves)

#inter-grow
ITG = {}
lastNodes = []
maxN = len(nodes)
for ni in range(maxN):
  lr = nodes[ni][0]
  lc = nodes[ni][1]
  print(lc,n,PairOnes(M, lc, n))
  if PairOnes(M, lc, n) >0:
    print([[ir,ic] for ir in range(lc+1, n-1) for ic in range(lc+1,n) if [ir,ic] in nodes])
    ITG[(lr,lc)]=[[ir,ic] for ir in range(lc+1, n-1) for ic in range(lc+1,n) if [ir,ic] in nodes]
  else:
    lastNodes.append([lr,lc])
print(ITG)
print(lastNodes)

"""探索
[0,10]: (3x1+(2x2+2+1)+(2+1+1)+(2+1)+1)+sum(sum(M))+1

1.   [1,3],


    1.1  [4,9]
    2.1  [7,9]
    3.1  [8,9]

2.   [1,9]-


    2.1.  [2,5]-
           2.1.1 [3.4]
    2.2  [2,6]-        
           2.2.1 [3,4]
3.   [2,5]-  XX ,[7,9]


    3.1  [3,4]
            
4.   [2,5]-  XX ,[8,9]


    4.1  [3,4]

5.   [3,7],


    5.1  [8,9]
6.   [3,8]

"""

(3*1+(2*2+2+1)+(2+1+1)+(2+1)+1)+sum(sum(M))+1

print(nodes)
print(tuple(nodes[1]) in IG)
print(IG[tuple(nodes[1])])
#[[1, 3], [1, 9], [2, 5], [2, 6], [3, 4], [3, 7], [3, 8], [4, 9], [7, 9], [8, 9]]
#level = [1,1,2,2,3,2,2,1,1,1]
#depth = [1,3,2,2,1,2,1,1,1,1]
#branch = [1.1,1.2,1.2(1),1.2(2)，1.2(1)(1)/1.2(2)(1),1.2(3),1.2(4),1.2(5),1.1+1,1.1+2,1.1+3]
#childs = [[],[[2, 5], [2, 6], [3, 7], [3, 8]],[3, 4],[3, 4],[],[],[],[],[],[]]
#tree = [[[1, 3],[7, 9]],[[1, 3],[8, 9]],[[2, 5],[7, 9]],[[2, 5],[8, 9]],[[2, 6],[7, 9]],[[2, 6],[8, 9]],[[1, 3],[4, 9]],[[3, 7],[8, 9]],[[3, 4],[8, 9]],[1,9]]
#1+sum(sum(M))+(3+5+2)
print(tuple(nodes[3]) in IG)
print(IG[tuple(nodes[3])])

print(tuple(nodes[0]) in ITG)
print(ITG[tuple(nodes[0])])

"""#[[1, 3], [1, 9], [2, 5], [2, 6], [3, 4], [3, 7], [3, 8], [4, 9], [7, 9], [8, 9]]
#level = [1,1,2,2,3,2,2,1,1,1]
#depth = [1,3,2,2,1,2,1,1,1,1]
#branch = [1.1,1.2,1.2(1),1.2(2)，1.2(1)(1)/1.2(2)(1),1.2(3),1.2(4),1.2(5),1.1+1,1.1+2,1.1+3]
#childs = [[],[[2, 5], [2, 6], [3, 7], [3, 8]],[3, 4],[3, 4],[],[],[],[],[],[]]
#tree = [[[1, 3],[7, 9]],[[1, 3],[8, 9]],[[2, 5],[7, 9]],[[2, 5],[8, 9]],[[2, 6],[7, 9]],[[2, 6],[8, 9]],[[1, 3],[4, 9]],[[3, 7],[8, 9]],[[3, 4],[8, 9]],[1,9]]
#1+sum(sum(M))+(3+5+2)    
"""

table = {'AU':2,'UA':2,'GC':2,'CG':2,'A':1,'U':1,'G':1,'C':1,'':1}
def motzkin(sts):
  if sts not in table:
    c = motzkin(sts[1:])
    for i in range(1,len(sts)):
      if(RNA[sts[0]]==sts[i]):
        c += motzkin(sts[1:i])*motzkin(sts[i+1:])
    table[sts] = np.mod(c,10000000)
  return table[sts]
s = 'AUAU'
motzkin(s)